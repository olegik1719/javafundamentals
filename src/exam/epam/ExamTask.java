/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Дано число, вернуть два числа,         
 * полученных упорядочиванием цифр по возрастанию/убыванию без ведущих нулей
 * Алгоритм родился на обратной дороге, тескт не проверялся компилятором.
 * Написан с "одного дубля".
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
package exam.epam;

public class ExamTask{
  public static void main(String[] args){
    int ord = 10; // система счисления;
    int n=65535;  // Оно дано.
    int nCopy = n; // Только для того, чтобы потом его вывести
    int digits[ord]; //инициализируется нулями
    
    while (n>0){ // Используем корзинную сортировку.
      digits[n % ord]++;
      n = n / ord;
    }
    
    System.out.printf("Изначальное число: %d%n",nCopy);
    
    //Первый вариант вывода: выводим строки
    
    System.out.printf("Чиcло по возрастанию: ");
    for (int i = 1; i < 10;i++){
      for (int j=0; j < digits[i]; j++){
         System.out.printf("%d%",i);
      }
    }
    
    System.out.printf("%nЧисло по убыванию: ");
    for (int i = 0; i < 10;i++){
      for (int j=0; j < digits[9-i]; j++){
         System.out.printf("%d%",(9-i));
      }
    }      
    
    System.out.printf("%n");
    
    // Второй вариант, формируем и выводим числа.
    // ИМХО, более предпочтительный.
    
    int up;   // по возрастанию
    int down; // по убыванию
    
    for (int i = 0; i < 10;i++){
      for (int j=0; j < digits[i]; j++){
         up=up*10+i;
         down=down*10+(9-i);
      }
    }
    
    System.out.printf("Число по возрастанию: %d%nЧисло по убыванию: %d%n", up, down);
  }
}
